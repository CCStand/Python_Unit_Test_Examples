#You need to import any test packages that your tests will use
import pytest #allows pytest to run the tests in this file
from hypothesis import given, example, strategies as st #allows you to use hypothesis to pass testing strategies to your tests

#You also need to import the code that you are trying to test
import my_package.squish as sq
from my_package.squish import Squishable_Class

import string

#The line of code starting with '@' is a decorator, essentially shorthand for applying something to a user-defined function
#The 'example' decorator is part of hypothesis and allows you to pass explicit values to your test function
#The 'given' decorator is also part of hypothesis and allows you to pass a range of auto-generated values to your test function
#Here we are passing the 'text' strategy to auto-generate strings containing edge-case characters that might cause the test to fail
@example("Test", "This")
@given(st.text(), #a hypothesis-generated string
       st.text())
def test_imperfect_squish(thing1, thing2):
    """Tests the imperfect_squish function with the two strings 'Test' and 'This' and then tests the imperfect_squish
       function with two hypothesis-generated strings."""
    print(f"({thing1}, {thing2})")
    expected = str(thing1) + str(thing2)
    got = sq.imperfect_squish(thing1, thing2)
    assert expected == got, f"Expected {expected} but got {got}"


@given(st.one_of(st.text(), st.integers()), #generates either a hypothesis-generated string, or a hypothesis-generated integer
       st.one_of(st.text(), st.integers()))
def test_robust_imperfect_squish(thing1, thing2):
    """Tests the imperfect_squish function with some combination of hypothesis-generated strings and integers."""
    print(f"({thing1}, {thing2})")
    expected = str(thing1) + str(thing2)
    got = sq.imperfect_squish(thing1, thing2)
    assert expected == got, f"Expected {expected} but got {got}"


@given(st.one_of(st.text(alphabet=('/','!','.')), st.integers()), #the strings generated by hypothesis will be made from only !./
       st.one_of(st.text(alphabet=string.ascii_letters), st.integers())) #the strings will contain only ASCII characters
def test_fixed_squish(thing1, thing2):
    """Tests the squish function with some combination of hypothesis-generated strings and integers.
       Any strings generated for the first value will be made exclusively from the characters '/','!', and'.'
       and any strings generated for the first value will be made exclusively from ACII characters."""
    print(f"({thing1}, {thing2})")
    expected = str(thing1) + str(thing2)
    got = sq.squish(thing1, thing2)
    assert expected == got, f"Expected {expected} but got {got}"
    

@given(st.from_regex(r"[0-9]*"), #string containing a sequence of digits (but that may contain other characters)
       st.from_regex(r"[a-z]*", fullmatch=True)) #string consisting of only lower-case characters
def test_sparse_squish(thing1, thing2):
    """Tests the sparse_squish function with two hypothesis-generated strings, the first of which will contain
       a sequence of 0 or more digits (but may contain other characters), and the second of which will be a string 
       containing only lower-case letters."""
    print(f"({thing1}, {thing2})")
    expected = str(thing1) + " " + str(thing2)
    got = sq.sparse_squish(thing1, thing2)
    assert expected == got, f"Expected {expected} but got {got}"


@given(st.from_regex(r"[0-9]* [A-Z]*", fullmatch=True), #a digit sequence and upper-case sequence separated by a space 
       st.from_regex(r"[A-Z]* {2,}[a-z]*", fullmatch=True)) #an upper-case sequence and lower-case sequence separated by multiple spaces 
def test_dense_squish(thing1, thing2):
    """Tests the dense_squish function with two hypothesis-generated strings, the first of which will be a string
       of 0 or more digits, followed by a space, followed by a sequence of 0 or more upper-case letters, and 
       the second of which will be a string of 0 or more upper-case letters, followed by two or more spaces, 
       followed by a sequence of 0 or more lower-case letters."""
    print(f"({thing1}, {thing2})")
    expected = str(thing1).replace(" ", "") + str(thing2).replace(" ", "")
    got = sq.dense_squish(thing1, thing2)
    assert expected == got, f"Expected {expected} but got {got}"

    
@given(st.emails(), #a hypothesis-generated string formatted as an email
       st.ip_addresses()) #a hypothesis-generated string formatted as an ip_address
def test_specifics_squish(thing1, thing2):
    """Tests the squish function with two hypothesis-generated strings, the first of which will be a string
       formatted as an email, and the second of which will be a string formatted as an IP address."""
    print(f"({thing1}, {thing2})")
    expected = str(thing1) + str(thing2)
    got = sq.squish(thing1, thing2)
    assert expected == got, f"Expected {expected} but got {got}"
    
    
@given(st.lists(st.text())) #a hypothesis-generated list where each element is a string
def test_squish_list(thing_list):
    """Tests the squish_list function with a hypothesis-generated list where each element of the list is a
       hypothesis-generated string."""
    print(f"({thing_list})")
    expected = ""
    for element in thing_list:
        expected = expected + str(element)
    got = sq.squish_list(thing_list)
    assert expected == got, f"Expected {expected} but got {got}"


@given(st.lists(st.integers(), #a hypothesis-generated list where each element is an integer,
                min_size=2, max_size=3).map(sorted)) #the list has 2-3 elements, and the elements in the list are sorted
def test_list_squish_object(val_list):
    """Tests the squish_object function with a Squishable_Class object initialised with the values from a hypothesis-generated list
       where each element of the list is a hypothesis-generated integer, the list contains either 2 or 3 elements, and the elements
       of the list are ordered from smallest to largest."""
    print(f"({val_list})")
    expected = ""
    for val in val_list:
        val = str(val)
        expected = expected + str(val)
        
    squishable_object = Squishable_Class(*val_list)
    got = sq.squish_object(squishable_object)
    assert expected == got, f"Expected {expected} but got {got}"

#You can store hypothesis strategies as variables to be used later
#The 'builds' strategy allows you to generate custom objects
squishables = st.builds(Squishable_Class, #a hypothesis-generated Squishable_Class object instantiated with values from the below strategies
                        thing1=st.from_regex(r"[0-9]* [A-Z]"), 
                        thing2=st.one_of(st.text(), st.integers()), 
                        thing3=st.from_type(bool)) #a hypothesis-generated Boolean value
@given(squishables)
def test_object_squish_object(squishable_object):
    """Tests the squish_object function with a Squishable_Class object initialised with
       a hypothesis-generated string that is a sequence of 0 or more digits, followed by a space, followed by an upper-case letter,
       either a hypothesis-generated string, or a hypothesis-generated integer,
       a hypothesis-generated Boolean value."""
    print(f"({squishable_object})")
    expected = ""
    for val in squishable_object.get_attribute_val_list():
        expected = expected + str(val)
        
    got = sq.squish_object(squishable_object)
    assert expected == got, f"Expected {expected} but got {got}"